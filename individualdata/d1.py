x = 1 #by default integer will be having 0
# y = int(2)
# print(type(x))
# print(type(y))
# print(type(-5))
# print(x+y)
# print(x-y)
# print(x/y)
# print(x*y)
#
# print(abs(x-y))
# print(abs(-8))
# print(abs(8))
#arithmetic operations
# add = 1 + 2 #3
# sub = 1 - 2 #-1
# div = 1 / 2 #0.5
# mul = 1 * 2 #2
# mod = 115 % 10 #5
# print(mod)
# floordiv = 115 // 10 #11
# print(floordiv)
# dm = divmod(115, 10)
# print(dm)

# print(dir(int))

# print(type(1.5)) #by default float will be having 0.0
# print(type(1.))
# print(1.)
# print(type(-1.0))
# print(abs(+1.12))
# print(abs(-1.12))

# print(round(2.45))
# print(round(2.53))
# print(round(2.45, 1))
# print(round(2.44, 1))
# print(round(2.3456, 2))
# print(round(2.3456, 3))
# print(round(2.3454, 3))
# print(round(-2.3456, 3))

# print(round(1.456,2))
# print(round(1.456))

# import math
# print(math.trunc(1.456))
# print(math.trunc(1.56))
# x = math.trunc(2.56)
# print(type(x))

# x = int(1.5)
# y = float(1)
# print(x, y)


#complex by default it will be  0 + 0j or 0j imaginary part will be having j or J
# c = 1 + 2j
# c1 = complex(1, 2)
# c2 = complex(1)
# c3 = complex()
# print(c)
# print(c1)
# print(c2)
# print(c3)
#
# add = c + c1 # 1+2j + 1+2j = 2+4j
# sub = c - c2 # 1+2j - 1+0j = 2j
# div = c / c1 # 1+2j / 1+2j = 1+0j
# mul = c * c1 # 1+2j * 1+2j = 1 + 4j (-3+4j)
# # dm = divmod(c, c2) #TypeError: can't take floor or mod of complex number.
# print(add, sub, div, mul, sep="##")


#boolean will have only True and False default value False
# x = True
# print(type(x))
# y = False
# print(type(y))
# z = bool()
# print(z)
# h = bool(5) #checking if something exist or not
# print(h)
# h = bool(0)
# print(h)
# h = bool(None)
# print(h)
# h = bool(-5)
# print(h)

